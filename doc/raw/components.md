# 组件篇

> 本篇介绍一些组件的结构与设计思路，并以此为载体记录一些好的设计实践。

## Toast组件（弹出式消息框）和MsgBox（消息框）
Toast组件是第一个做出来的，因此放在最前面。整个系统最初也是为围绕这个小物件来写的。\
在代码中能看出Toast组件是由MsgBox组件继承而来的，实际上是Toast先被写出来，然后发现需要一个能悬挂的消息框，于是才将Toast功能削减变成MsgBox，然后才使得Toast继承了MsgBox。

以Toast为例，其结构很简单，仅包含一个方框和多行字，因此渲染函数还是比较好写的。\
最初只有一行的空间，妄想着单片机懂得什么叫自动换行（笑），后来对`\n`字符做了特殊处理，实现了多行文本。\
然后为了达到`printf`那样的效果，又加上了`vsprintf`什么的，挺好玩的反正ww\

动画层面没什么难点，主要是在此期间完善了事件系统和动画钩子函数。因为整个动画是环环相扣的嘛，所以我写的流程就是：
> |--入场动画-->^(在n秒后挂载并启动结束动画)|   ...   ^|--结束动画-->^(删除元素)|

非常的严丝合缝，我很喜欢。

后面发现只要把退场动画变成用户函数，然后再加一个更改文字，就是MsgBox了，索性就把Toast的实现变成魔改MsgBox了

```c++
typedef struct {
    int16_t X;    //静态，被动参数
    int16_t Y;    //动画，被动参数
    uint16_t Width;  //静态，被动参数
    uint16_t Height; //静态，被动参数
    uint16_t TextMaxWidth;  //静态，被动
    char* Text;   //静态，主动
    uint8_t* LinePtrs;   //静态，被动
    uint8_t* LineWidth;  //静态，被动
    uint8_t LinePtrNum;  //静态，被动
} UI_MsgBoxArgs;
```
这是MsgBox的结构，前四个控制的方框，后三个是在文本输入之后拆成多行文本，空间换时间的行为。\
建议看看我怎么拆的字符串的，我是直接原地拆解的wwwwww

## list组件
我感觉比较复杂的一个组件，但是复杂的点不在把他做出来，而是怎么把这个东西的逻辑设计出来。真是想了我好久...\
最初列表的设计是一个框框，里面装了若干选项。选中的框框就用另一个框框框起来（并不好看，但是当时忙着先做出来）\
因为我一开始想的就是写一套函数式的工具集，所以用户接口就理所应当的限定为了上滚，下滚和选中，毕竟是面向的单片机的，就没必要考虑触摸屏的那一套操作逻辑。\
我一开始执着于，因为我不能将所有的选项都渲染出来，所以我就一定不能碰那些没被显示的组件。\
因此最初都是有一个指针指示列表从哪里开始显示，这在考虑动画的时候遇到了极大的阻碍。在动画播放时，如果向上滚动，那么列表的显示范围就得向下增加一个，而指针不能动，要等动画结束后才能移动指针。\
同样在下滚时也有像类似的问题，这困扰了我好久。读者可以自己思考一下，这么设计会导致指针，显示长度，动画前后这几个变量之间发生复杂的纠缠。\
后来是意识到，如果是屏幕外的内容，我直接在渲染层跳过不就好了。茅塞顿开，很快就写出了整个功能。\
所以在数据层面，列表没有被切开，只是屏幕作为一个视窗在整个列表上滑动。\

关于那个回调函数，我本来还在纠结到底是传入一个索引还是字符串本身呢，后来一想去球，我直接把列表对象都给你你自己要什么拿什么不就好了。（笑）

```c++
typedef struct UI_ListArgs{
    int16_t X;
    int16_t Y;
    int8_t line_distance;  //两边线的间距，主要服务于动画
    uint16_t each_height;  //每个选项的高度
    uint8_t itemNum;
    String* items;
    uint8_t* itemWidth;
    uint8_t firstIndex;    //当前显示的第一个选项，用于判断是列表上滚还是框框下滚

    void (*confirm_Func)(UIComponent *list);

    UIAnimation *List_shake_anime;
    UIAnimation *List_box_mov_anime;
    UIAnimation *List_row_anime;  //用于复用的动画

    int8_t selected_index;   //当前选择的对象索引
    int16_t sel_box_X;
    int16_t sel_box_Y;
    int16_t sel_box_width;
    int16_t sel_box_height;   //选项框参数

} UI_ListArgs;
```
这个组件推动了动画的复用和可重复动画想法的落地，原本我写的动画结束是回到用户设定的终值，然后后面测试的时候就炸了hhh。
  
## Sprite精灵 和 sticker贴纸
从名字能看出来，这个东西是拿来做游戏的，里面写了些乱七八糟的，建议随用随改。这个组件我想记录的是，他提供了一种实时更新参数的思路。\
可以看到，组件的位置和速度参数是被写在渲染函数中的。由于渲染函数会被每一帧调用，所以这种方案是可行的。\
不过！我可能在后期会对这个渲染函数的调用进行优化，这种写法估计就不好使了..\

其实最早写的就是有动画时才更新，但好像遇到了一下问题，才采取了现在的方案。算了算了。

主要是sticker组件，这不是一个完整的组件。顾名思义，这是一个贴纸，结构如下：
```c++
typedef struct {
    uint16_t Width;  // 静态，被动参数
    uint16_t Height; // 静态，被动参数
    const uint8_t* Picture;  // 图像
    const uint8_t* Mask;     // 蒙版
} Sticker;
```
当调用Sticker_Draw时，会按照蒙版擦除特定区域，然后将图案直接绘制在屏幕上。这样子，在屏幕上显示的对象就不会实现突兀的框框了。\
这个组件可以被当作游戏精灵的子对象，类似png那种图片，可以方便的调用渲染。
