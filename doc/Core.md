# 核心介绍
> 此文档介绍NyaUI的大体框架。

## 主循环
框架的运行需要依靠一个主循环函数来进行各项任务的轮询，这个主循环函数就是`UI_LoopFunc`(ui_core.c)。
在这个函数中进行了**UI队列**(包含动画)和**事件队列**的遍历与处理。

## UI组件
### UI组件构成
UI组件的定义如下：
```c++
typedef struct UIComponent {
    struct UIComponent* prev;                     // 前一个组件
    struct UIComponent* next;                     // 后一个组件
    UIComponentState state;                       //（动画）状态
    
    void (*draw_func)(struct UIComponent*);       // 绘图函数
    void (*destroy_func)(struct UIComponent*);    // 销毁函数
    void* args;                                   // 组件控制参数
    UIAnimation* animation;                       // 动画对象
} UIComponent;
```
- 其中前三个参数不由用户控制，当用户调用组件操作函数时由内部维护。
- 绘图函数`draw_func`主要用于渲染组件，但还有一些用处，下文说。
- 销毁函数`destroy_func`用于销毁组件，在这个函数中需要销毁包含组件本身和内部**所有**动态申请的内存。
- 参数组`args`是组件最核心的部分，所有关于这个组件本身的数据将全部在这里保存。这里通常需要用户按照组件需求，设计一个参数结构体，并将这个结构体对象放在这个指针下。
- 动画`animation`是放置当前组件正在播放的动画的对象，关于`UIAnimation`结构与功能，下文详说。

### UI组件操作函数
 - `UI_RegisterComponent`组件注册函数，用于将组件放置在UI组件链表里，这意味着组件开始工作。
 - `UI_RemoveComponent`组件移除函数，用于将组件移除UI链表。这将同时调用`destroy_func`

## 动画
动画组件与UI组件是包含关系，一个组件在一个时刻只会有一个正在播放的动画，虽然这会带来一些限制，但仍具有十足的拓展性。

该系统参考了关键帧的思想，并向其中加入了非线性函数这一特性，使得开发者能轻易地控制动画中各项参数，
同时动画也会变得更加灵动。

### 动画组件构成
动画组件定义如下：
```c++
typedef float (*UIAnimationFunc)(float);
typedef  int16_t st_ed_g[2];

typedef struct UIAnimation{
    uint8_t UpdateArgsNum;          //动画更新参数个数
    int16_t **UpdateArgs;           //动画更新参数列表
    int16_t (*UpdateArgSt_Ed)[2];   //动画更新参数起始和终止位置
    UIAnimationFunc* UpdateFuncs;   //动画更新曲线函数列表
    uint32_t duration;              // 动画总时长（ms）
    
    void (*StartFunc)(UIComponent*);        //开始钩子函数
    void (*FinishedFunc)(UIComponent*);     //结束钩子函数
    
    uint32_t start_tick;             // 动画开始时间（滴答数）
} UIAnimation;
```
- `UIAnimationFunc`是动画曲线函数，以一个范围为0-1的参数来描述动画的时间进度，返回此时按照曲线，动画的行进进度。其他情况后续详说。
- `st_ed_g`为“start-end group”，描述某个参数在动画中的起始位置。是一个包含两个16位整数的数组。

- `UpdateArgsNum`是动画中需要更新的参数个数。请务必保证这个参数和下面所有提供的数组的长度都对应上
- `UpdateArgs`是需更新的参数对应的地址，是一个16位整数指针列表。
- `UpdateArgSt_Ed`是需更新的参数的始末值，是一个`st_ed_g`列表。
- `UpdateFuncs`是更新参数时使用的曲线函数，是一个`UIAnimationFunc`列表。
- `duration`是动画持续时间。

- `StartFunc`和`FinishedFunc`分别是动画开始播放和结束时调用的函数，不使用时请赋予一个**空函数**指针，而**不要赋0**

- `start_tick`是动画起始时间，无需用户手动管理。
### 动画操作函数
- `Anime_Create`用于创建动画示例，用户需按照参数列表提供各项参数，此函数调用时，用户直接传入字面量或局部变量即可，函数内部会为这些内容重新分配空间并复制内容。
- `Anime_Destroy`（或`cAnime_Destroy`）用于销毁动画对象。
- `UI_StartAnime`(ui_core.c)用于启动动画
### 动画处理周期
具体实现请参照`process_anime`(ui_core.c)函数，此处仅讲述大致流程。

1. 当用户调用`UI_StartAnime`时，组件进入等待状态(`UI_STATE_WAIT_FOR_ANIMATE`)
2. 当组件被轮询时，调用开始函数，并将状态改为正在动画(`UI_STATE_ANIMATING`)
3. 处理动画时，先通过时间计算出当前进度，再按照曲线计算出参数进度，再更新动画。
4. 当计算当前进度时，发现进度>1，即动画已经结束了时会将进度**置于1**，更新组件组件状态，并执行结束函数。
5. 若组件处于一般状态(`UI_STATE_NORMAL`)，那么也会调用渲染函数。

> 开始函数在渲染函数前调用，结束函数在渲染函数后调用。

### 动画曲线函数说明
动画曲线函数描绘了参数的变化路径，以此来实现各种灵动的效果。

函数接受一个0~1的浮点数，描述当前动画进度，按照函数本身返回一个0~1进度值。

这个函数事实上是一个数学函数`f(x)`，可以是连续的，也可以是离散的。但一定要保证f(x)在x等于0~1之间都有定义。

例如，提供一个函数实现
```c++
float line(float x){
    return x;
}
```
这个函数描述了一个线性运动，故对象将匀速运动。

当动画执行完毕后，该参数会停留在`f(1)`的位置上，如果担心有累计误差，请为`x == 1`单独添加一条分支。

特别的，如果`f(1) == 0`，则表明该动画是一个往返动画，在执行完毕动画后，参数将保持初始的值。
如果想实现往返动画，那么请留意`st_ed_g`参数，该动画的结束值则成为了一个动画幅度绑定的参数。即：
设`f(x)`的最大值为`k`，那么运动幅度就是k乘始末值之差。

`f(x)`的返回值可以超出0-1的区间，但是建议不要超的太多，往返动画保持在±1.5的区间中为宜。单向动画建议0-1.5。

### 动画的衔接
如果两个动画中间需要进行进行衔接，例如列表中不同选项间的切换，通常可以进行动画对象的复用。即，将使用过的动画对象进行保存，然后只修改部分参数，并在使用时将他挂载至对象上。\
在编写这类代码时，可以考虑这几个方面：
1. 在做动画衔接时，为了保持流畅性，我们可以将起始位置设置为组件当前位置，只着重考虑目标位置。
2. 目标位置的来源有很多，最简单直接的方式就是将目标位置设置在某个静态变量或对象属性中。
3. 目标位置有时还可以是上一个动画目标位置的相对位置，这是我们只需要在原参数的基础上进行部分修改就好了。
4. 设置完后，还需要调用一次`UI_StartAnime`函数，来重置动画系统里的各项参数。
